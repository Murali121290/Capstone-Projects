pipeline {
    agent any
    environment {
        ECR_URL     = "${env.ECR_URL}"
        AWS_REGION  = "ap-south-1"  // Fixed: consistent region
        SONAR_HOST  = "http://localhost:9000"
    }
    
    stages {
        stage('Checkout SCM') {
            steps {
                checkout scm
            }
        }

        stage('Code Quality Check') {
            parallel {
                stage('SonarQube Analysis') {
                    steps {
                        withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_LOGIN')]) {
                            sh '''
                            docker run --rm \
                                -e SONAR_HOST_URL=${SONAR_HOST} \
                                -e SONAR_LOGIN=$SONAR_LOGIN \
                                -v $(pwd)/jenkins:/usr/src \
                                -w /usr/src \
                                sonarsource/sonar-scanner-cli
                            '''
                        }
                    }
                }
                stage('Security Scan') {
                    steps {
                        sh '''
                        # Run security tools like trivy or bandit
                        docker run --rm -v $(pwd):/src aquasec/trivy fs /src || true
                        '''
                    }
                }
            }
        }

        stage('Build & Push Docker') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
                    script {
                        def image = "${env.ECR_URL}:${BUILD_NUMBER}"
                        def ecrRegistry = env.ECR_URL.split('/')[0]
                        
                        sh """
                        aws ecr get-login-password --region ${AWS_REGION} | \
                            docker login --username AWS --password-stdin ${ecrRegistry}
                        
                        docker build -t ${image} ./app
                        docker push ${image}
                        """
                        env.IMAGE = image
                    }
                }
            }
        }

        stage('Deploy to Minikube') {
            steps {
                script {
                    sh """
                    minikube kubectl -- apply -f k8s/
                    minikube image load ${env.IMAGE} || true
                    minikube kubectl -- set image deployment/vulnerable-app vulnerable-app=${env.IMAGE}
                    minikube kubectl -- rollout status deployment/vulnerable-app --timeout=300s
                    """
                }
            }
        }
        
        stage('Smoke Test') {
            steps {
                sh """
                minikube kubectl -- wait --for=condition=ready pod -l app=vulnerable-app --timeout=120s
                # Add actual API test calls here
                """
            }
        }
    }

    post {
        always {
            echo "Pipeline execution completed - Build: ${BUILD_NUMBER}"
            cleanWs()  // Clean workspace
        }
        success {
            echo 'Pipeline succeeded! Application deployed successfully.'
        }
        failure {
            echo 'Pipeline failed. Check logs for details.'
            // Add notification here (email, Slack, etc.)
        }
    }
}
